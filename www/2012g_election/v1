#!/usr/bin/perl -w
use strict;
use warnings;
use utf8;
use FindBin;
FindBin::again();
use CGI::Carp qw(warningsToBrowser fatalsToBrowser);
use CGI qw(:standard escape escapeHTML -utf8 -oldstyle_urls);
use Encode;
use JSON;
use XML::Simple;
use Benchmark;
use Time::HiRes qw(gettimeofday tv_interval);
use POSIX qw(strftime);
use File::Basename;

my ($BM1, $T01) = (new Benchmark, [gettimeofday]);

CGI->compile();

# This line should be commented out if output data is encoded properly.
#binmode STDOUT, ":encoding(UTF-8)";

our $q    = new CGI; $q->charset('utf-8'); # for proper escapeHTML
our $json = new JSON; $json->allow_nonref->allow_blessed->utf8(1)->pretty(1);

# You should not call CGI::path_info() which does not support
# debugging mode from cmdline input.
my ($path, $query, $suffix) = fileparse($q->path_info || "/index", ".xml", ".json", ".txt");
my $from     = param('from')  || 0;
my $count    = param('count') || 100;
my $callback = param('callback');
my $content_type = "application/json"; # http://en.wikipedia.org/wiki/JSON#MIME_type
my $full_url = $q->url(-full=>1);

$suffix = ".json" unless $suffix;
$content_type = "application/javascript" if $callback and $suffix eq ".json";
$content_type = "application/xml"        if $suffix eq ".xml";

print $q->header(-charset=>'utf-8', -type=>$content_type);
print jsonp_header($callback) if $suffix eq ".json";

my %dispatch = (
  index                       => \&handler_index,
  district_list               => \&district_list,
  district                    => \&district,
  sns_map                     => \&sns_map,
  sns_map_detail              => \&sns_map_detail,
  realtime_ddm_dynamic_status => \&realtime_ddm_dynamic_status,
  realtime_ddm_dynamic_list   => \&realtime_ddm_dynamic_list,
  candidate                   => \&election_candidate,
  tw_realtime_list            => \&tw_realtime_list,
  tw_rt_list                  => \&tw_rt_list,
);

my $output = {};
if ( defined $dispatch{$query} ) {
  my %result = &{$dispatch{$query}};
  map { $output->{$_} = $result{$_}; } keys %result;
} else {
  $output->{hello} = "world!";
}

decode_utf8_in_complex_data($output);

my ($BM2, $T02) = (new Benchmark, [gettimeofday]);
$output->{debug_info} = debug_info($BM1, $BM2, $T01, $T02);

print $json->encode($output)  if $suffix eq ".json";
print XMLout($output)         if $suffix eq ".xml";
print jsonp_footer($callback) if $suffix eq ".json";

1;

sub jsonp_header {
  my ($callback) = @_;
  return <<END if $callback;
if (typeof $callback === "function") $callback(
END
  return "";
}

sub jsonp_footer {
  my ($callback) = @_;
  return <<END if $callback;
);
END
  return "";
}

sub debug_info {
  my ($t1, $t2, $t01, $t02) = @_;
  my $elapsed   = tv_interval($t01, $t02);
  my $benchmark = timestr(timediff($t2, $t1));
  my $mod_perl  = $ENV{MOD_PERL} || "";
  return { 
    elapsed   => "$elapsed secs",
    benchmark => "$benchmark",
    mod_perl  => "$mod_perl",
    json      => JSON->backend,
    encoding_test => "한글이 제대로 보이는지 점검합니다.",
  };
}

sub next_urls {
  my ($uri) = @_;
  return map { "$_$uri" } qw(
        http://search-twitter-app1:3080
        http://search-twitter-app2:3080
        http://search-twitter-app3:3080
    );
}

sub decode_utf8_in_complex_data {
  my ($var) = @_;
  if ( ref $var eq "HASH" ) {
    foreach my $key ( keys %{$var} ) {
      next unless defined $var->{$key};
      if ( ref $var->{$key} ) {
        decode_utf8_in_complex_data($var->{$key});
      } else {
        eval {
          utf8::is_utf8($var->{$key})
            or $var->{$key}
            = Encode::decode("utf8", $var->{$key});
        };
        warn "\$var->{$key} has invalid character." if $@;
      }
    }
  } elsif ( ref $var eq "ARRAY" ) {
    for ( my $i = 0; $i <= $#{$var}; $i++ ) {
      next unless defined ${$var}[$i];
      if ( ref ${$var}[$i] ) {
        decode_utf8_in_complex_data(${$var}[$i]);
      } else {
        eval {
          utf8::is_utf8(${$var}[$i])
            or ${$var}[$i] = Encode::decode("utf8", ${$var}[$i]);
        };
        warn "\$var[$i] has invalid character." if $@;
      }
    }
  } else {
    ; # do nothing
  }
  return $var;
}

sub handler_index {
  return ( index => { map { $_ => "$full_url/$_" } sort keys %dispatch } );
}

sub mysql_dbh {
  use DBI;
  my $dbh = DBI->connect(@_);
  return $dbh;
}

###############################################################################
sub app1_schema {
  my $schema  = "twapp1";
  unless ( $q->server_port eq "80"
       and defined $ENV{GATEWAY_INTERFACE} ) {
     $schema  = "twapp1t";
  }
  return $schema;
}

sub app2_schema {
  my $schema  = "twapp2";
  unless ( $q->server_port eq "80"
       and defined $ENV{GATEWAY_INTERFACE} ) {
     $schema  = "twapp2t";
  }
  return $schema;
}

sub app1_mysql {
  my @slaves = (
    q(10.10.208.21),
    q(10.10.208.31),
    q(10.10.208.77),
  );
  my $host = $slaves[ int(rand(3)) ];
  my $schema  = "twapp1";
  my $db_user = "twapp1";
  my $db_pass = "app!@#";
  unless ( $q->server_port eq "80"
       and defined $ENV{GATEWAY_INTERFACE} ) {
     $schema  = "twapp1t";
     $db_user = "twapp1t";
     $db_pass = "app123";
  }
  return (qq(dbi:mysql:database=$schema;host=$host), $db_user, $db_pass);
}

sub app2_mysql {
  my @slaves = (
    q(10.10.208.21),
    q(10.10.208.31),
    q(10.10.208.77),
  );
  my $host = $slaves[ int(rand(3)) ];
  my $schema  = "twapp2";
  my $db_user = "twapp1";
  my $db_pass = "app!@#";
  unless ( $q->server_port eq "80"
       and defined $ENV{GATEWAY_INTERFACE} ) {
     $schema  = "twapp2t";
     $db_user = "twapp1t";
     $db_pass = "app123";
  }
  return (qq(dbi:mysql:database=$schema;host=$host), $db_user, $db_pass);
}

sub realtime_dbh {
  use DBI;
  my $database = q(dbi:mysql:database=realtime;host=10.30.143.73);
  my $db_user = q(cdwuser);
  my $db_pass = q(cdwuserdb);

  my $dbh = DBI->connect($database, $db_user, $db_pass);
  return $dbh;
}
###############################################################################
sub percent {
  my ($count, $total) = @_;
  return sprintf("%.2f", ($total != 0)?(100 * $count / $total):0);
}
###############################################################################
sub district_list {
  my $limit     = param('limit') || 15;
  my $asof      = param('asof')  || strftime("%Y%m%d%H%M%S", (localtime));
  my $asof_datetime =
       sprintf("%04d-%02d-%02d %02d:%02d:%02d",
               unpack("A4A2A2A2A2A2", $asof.("0"x12)));
  my $interval  = param('interval') || 3600;

  my $app2_dbh = mysql_dbh( app2_mysql() );
# 격전지별 전체 후보 추출
  my $sql = q{
SELECT 
    c.sido_cd, c.sido_name, c.sido_short_name, c.cp_election_district_id, 
    c.election_district_short_name, group_concat(c.candidate_name) as candidate_name,
    d.x as wcongnamul_x, d.y as wcongnamul_y
FROM candidate c, district_map_coordinates d
WHERE c.cp_election_district_id = d.cp_election_district_id
GROUP BY cp_election_district_id
  };
  my $list = $app2_dbh->selectall_arrayref($sql, { Slice => {} });

  my $app1_dbh = mysql_dbh(app1_mysql());
# 전체 후보자 언급 횟수 추출(default: 1시간)
  $sql = q{
SELECT word, sum(mention_count) as cnt
FROM wave_rank_mention_count 
WHERE date_sub(?, interval ? second) <= pub_date_begin
  AND pub_date_begin <= ?
GROUP BY word
  };
  my $counts_ref = $app1_dbh->selectall_arrayref($sql, { Slice => {} },
    $asof_datetime, $interval, $asof_datetime);

# 카운트 정보를 저장하기 위한 임시 배열, 전체 카운트 저장
  my %counts = ();
  my $total = 0;
  foreach ( @{$counts_ref} ) {
    $counts{$_->{word}} = $_->{cnt};
    $total = $total + $_->{cnt};
  }

# 격전지에 해당하는 모든 후보자의 언급한 글 합산
  foreach ( @{$list} ) {
    $_->{tw_mentioned_count} = 0;
    foreach my $candidate (split(',', $_->{candidate_name})) {
      $_->{tw_mentioned_count} = $_->{tw_mentioned_count} + $counts{$candidate} if exists $counts{$candidate}
    }

    $_->{tw_mentioned_share} = percent($_->{tw_mentioned_count}, $total);
  }

# 언급한 글 순으로 정렬
  my @sorted = sort {$b->{tw_mentioned_count} <=> $a->{tw_mentioned_count}} @{$list};

# limit 에 따른 초과분 삭제
  foreach my $index(0 .. $#sorted) {
    delete $sorted[$index] if $index > $limit - 1;
  }

  my $help = {
    "API:name" => "격전지 왼쪽 리스트",
    "API:desc" => "이 시각 SNS 격전지에서 사용, 기본 15개",
    sido_cd => "특별/광역/도 코드",
    sido_name => "특별/광역/도 이름",
    sido_short_name => "특별/광역/도 이름의 약칭",
    cp_election_district_id => "CP_선거구ID",
    election_district_name => "선거구 이름",
    election_district_short_name => "선거구 이름의 약칭",
    tw_mentioned_count => "트위터에서 이름이 언급된 횟수",
    tw_mentioned_share => "트위터에서 이름이 언급된 점유율(%)",
    wcongnamul_x => "지도 좌표",
    wcongnamul_y => "지도 좌표",
  };

  return (
    results => \@sorted,
    help => $help,
    debug => {
      app1_mysql => (app1_mysql())[0],
      app2_mysql => (app2_mysql())[0],
      asof => $asof,
      asof_datetime => $asof_datetime,
    },
  );
}

sub district {
  my $id = param('id');

  my @mysql_dsn = app2_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
# 특정 격전지 후보 추출
  my $sql = q{
SELECT 
       c.homo_id, c.cp_person_id, c.candidate_name, c.election_symbol,
       c.cp_party_id_1, c.cp_party_id_2, c.party_name, c.party_short_name,
       c.twitter_id, c.cp_election_district_id,
       d.x as wcongnamul_x, d.y as wcongnamul_y
FROM candidate c, district_map_coordinates d
WHERE c.cp_election_district_id = d.cp_election_district_id
AND c.cp_election_district_id = ?
  };
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} }, $id);
  
  $dbh = mysql_dbh(app1_mysql());
# 최근 6일간 전체 언급 수 추출
  $sql = q{
SELECT date(pub_date_begin) as `date`, sum(mention_count) as `sum` 
FROM wave_rank_mention_count
GROUP BY date(pub_date_begin)
ORDER BY date desc
LIMIT 6
  };
  my $counts_ref = $dbh->selectall_arrayref($sql, { Slice => {} });

# 전체 카운트 저장
  my %totalcount = ();
  foreach ( @{$counts_ref} ) {
    $totalcount{$_->{date}} = $_->{sum};
  }

  foreach my $row ( @{$list} ) {
# 최근 6일간 후보자 언급 수 추출
    $sql = q{
SELECT date(pub_date_begin) as `date`, sum(mention_count) as `cnt` 
FROM wave_rank_mention_count
WHERE word = ?
  AND pub_date_begin > date_sub(now(), interval 5 day)
GROUP BY date(pub_date_begin)
ORDER BY date desc
LIMIT 6
  };
    my $mentions_ref = $dbh->selectall_arrayref($sql, { Slice => {} }, Encode::decode("utf8",$row->{candidate_name}));

# 카운트 정보를 저장하기 위한 임시 배열
    my %counts = ();
    foreach ( @{$mentions_ref} ) {
      $counts{$_->{date}} = $_->{cnt};
    }

# 6일간 점유율 계산, 없으면 0으로 채움
    my %shared_history = ();
    for (my $i=0;$i < 6;$i++) {
      my $date = strftime("%Y-%m-%d", (localtime(time - $i*60*60*24)));
      $shared_history{$date} = exists $counts{$date}
                              ? percent($counts{$date},$totalcount{$date}) : 0;
    }
    $row->{tw_shared_history} = \%shared_history;
  }

  my $help = {
    "API:name" => "격전지 상세",
    "API:desc" => "",
    nownum  => "순위",
    homo_id => "통합검색 인물ID",
    cp_person_id => "CP 인물ID",
    candidate_name => "후보자 이름",
    election_symbol => "기호",
    cp_party_id_1 => "CP 정당ID",
    cp_party_id_2 => "CP 정당ID",
    party_name => "정당이름",
    party_short_name => "정당이름 약칭",
    twitter_id => "트위터ID",
    tw_shared_history => "최근 6일간 점유율 히스토리(%)",
    wcongnamul_x => "지도 좌표",
    wcongnamul_y => "지도 좌표",
  };

  return (
    results => $list,
    help => $help,
    debug => {
      app1_mysql => (app1_mysql())[0],
      app2_mysql => (app2_mysql())[0],
    },
  );
}

sub sns_map {
  my $limit     = param('limit') || 100;
  my $candidate_type = param('candidate') || 'actual';
  my $asof      = param('asof')  || strftime("%Y%m%d%H%M%S", (localtime));
  my $asof_datetime =
       sprintf("%04d-%02d-%02d %02d:%02d:%02d",
               unpack("A4A2A2A2A2A2", $asof.("0"x12)));
  my $interval  = param('interval') || 86400;

  use Time::localtime;
  my $t = localtime;
  
  my $date = param('date') || sprintf( "%04d-%02d-%02d", $t->year + 1900, $t->mon + 1, $t->mday);

  my @mysql_dsn = app1_mysql();
  my $app1_schema = app1_schema();
  my $app2_schema = app2_schema();
  my $dbh = mysql_dbh(@mysql_dsn);
# 특정일 전체 언급 수 추출
  my $sql = qq{
SELECT sum(mention_count)
FROM $app1_schema.wave_rank_mention_count
WHERE date_sub(?, interval ? second) <= pub_date_begin
  AND pub_date_begin <= ?
  };
  my $totalcount = $dbh->selectrow_arrayref($sql, { Slice => {} },
    $asof_datetime, $interval, $asof_datetime);

# 특정일에 따른 후보자 언급 수
  $sql = qq{
SELECT * FROM
(
   SELECT word, sum(mention_count) as tw_mentioned_count, date(pub_date_begin) as `date`
   FROM $app1_schema.wave_rank_mention_count
   WHERE date_sub(?, interval ? second) <= pub_date_begin
     AND pub_date_begin <= ?
   GROUP BY word 
   ORDER BY tw_mentioned_count DESC 
) wc,
$app2_schema.candidate
WHERE wc.word = $app2_schema.candidate.candidate_name
ORDER BY tw_mentioned_count DESC
LIMIT ?
  };
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} },
    $asof_datetime, $interval, $asof_datetime, $limit);

# 이름과 매칭되는 후보자 정보 추출
  $dbh = mysql_dbh(app2_mysql());
  foreach my $row ( @{$list} ) {
    $row->{tw_mentioned_total} = @{$totalcount}[0];
    $row->{tw_mentioned_share} = percent($row->{tw_mentioned_count}, @{$totalcount}[0]);

    $row->{cp_party_id} = $candidate_type eq 'potential'
                        ? $row->{cp_party_id_1} : $row->{cp_party_id_2};
  }

# 후보자 정보 homo_id 가 null이 아닌 경우에만 유용한 결과로 필터링
  my @filtered;
  foreach my $index(0 .. $#{$list}) {
    push(@filtered, ${$list}[$index]) if defined ${$list}[$index]->{homo_id};
  }

  my $help = {
    "API:name" => "SNS 맵",
    "API:desc" => "후보자 SNS 점유율 맵을 그리기 위한 용도",
    word => "언급된 후보자명",
    tw_mentioned_count => "후보자 언급 횟수",
    tw_mentioned_total => "총선 후보 전체 트윗 수",
    tw_mentioned_share => "점유율",
    homo_id => "검색 인물 정보ID",
    cp_person_id => "CP 인물ID",
    cp_party_id => "CP 정당ID (candidate=actual 인 경우, cp_party_id_2, candidate=potential 인 경우, cp_party_id_1)",
    cp_election_district_id => "CP_선거구ID",
  };

  return (
    results => $list,
    help => $help,
    debug => {
      app1_mysql => (app1_mysql())[0],
      app2_mysql => (app2_mysql())[0],
      asof => $asof,
      asof_datetime => $asof_datetime,
    },
  );
}

sub sns_map_detail {
  my $homo_id = param('homo_id');
  my $candidate_type = param('candidate') || 'actual';

# 후보자 정보 추출
  my @mysql_dsn = app2_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
  my $sql = q{
SELECT *
FROM candidate 
WHERE homo_id = ?
  };
  my $candidate = $dbh->selectrow_hashref($sql, { Slice => {} }, $homo_id);

  $dbh = mysql_dbh(app1_mysql());
# 최근 6일간 후보자 언급 수 추출
  $sql = q{
SELECT date(pub_date_begin) as `date`, sum(mention_count) as `cnt` 
FROM wave_rank_mention_count
WHERE word = ?
AND pub_date_begin > date_sub(now(), interval 5 day)
GROUP BY date(pub_date_begin)
ORDER BY date desc
LIMIT 6
  };
  my $mentions_ref = $dbh->selectall_arrayref($sql, { Slice => {} }, Encode::decode("utf8", $candidate->{candidate_name}));
  my %mentioned_history = ();
  my %rt_history = ();
  my %tw_history = ();
# 6일간 언급, RT, 트윗 수 기록
  foreach my $r ( @{$mentions_ref} ) {
    $mentioned_history{$r->{date}} = $r->{cnt};
    $rt_history{$r->{date}} = int(rand(1000));
    $tw_history{$r->{date}} = int(rand(10));
  }
  $candidate->{tw_mentioned_history} = \%mentioned_history;
  $candidate->{tw_rt_history} = \%rt_history;
  $candidate->{tw_tweet_history} = \%tw_history;

  $candidate->{cp_party_id} = $candidate_type eq 'potential'
                            ? $candidate->{cp_party_id_1} : $candidate->{cp_party_id_2};

# 언급한 글, 새 글, 소문난 리스트 임시
  my @tweets;
  my @mentions;
  my @rts;
  for (my $i=0;$i<10;$i++) {
    my %tweet = (
                  "date" => "2012-02-29 13:00:".(int(rand(49)) + 10),
                  "tweet" => "로렘 입섬 돌로어 시트 아메트, 콘섹테투어 아데피시시 엘리트, 세드 도 에이우스모드 템",
                  "twitter_id" => "xxxxx",
                  "permalink" => "twitter.com/xxxxx/28480802",
                );
    my %mention = (
                  "date" => "2012-02-29 13:00:".(int(rand(49)) + 10),
                  "tweet" => "로렘 입섬 돌로어 시트 아메트, 콘섹테투어 아데피시시 엘리트, 세드 도 에이우스모드 템",
                  "twitter_id" => "xxxxx",
                  "permalink" => "twitter.com/xxxxx/28480802",
                );
    my %rt = (
                  "date" => "2012-02-29 13:00:".(int(rand(49)) + 10),
                  "tweet" => "로렘 입섬 돌로어 시트 아메트, 콘섹테투어 아데피시시 엘리트, 세드 도 에이우스모드 템",
                  "twitter_id" => "xxxxx",
                  "permalink" => "twitter.com/xxxxx/28480802",
                );

    push(@tweets, \%tweet);
    push(@mentions, \%mention);
    push(@rts, \%rt);
  }
  $candidate->{tw_tweets} = \@tweets;
  $candidate->{tw_mentions} = \@mentions;
  $candidate->{tw_rts} = \@rts;

  $candidate->{tw_tweets_count} = int(rand(1000));
  $candidate->{tw_following_count} = int(rand(10000));
  $candidate->{tw_followers_count} = int(rand(10000));
 
  my $help = {
    "API:name" => "SNS 맵 상세",
    "API:desc" => "후보자의 SNS 관련 상세 정보",
    twitter_id => "후보자 트위터 ID",
    candidate_name => "후보자명",
    tw_mentioned_history => "최근 6일간 언급된 수",
    tw_rt_history => "최근 6일간 RT 수",
    tw_tweet_history => "최근 6일간 후보자 트윗 수",
    sido_cd => "특별/광역/도 코드",
    sido_name => "특별/광역/도 이름",
    sido_short_name => "특별/광역/도 이름의 약칭",
    cp_election_district_id => "CP_선거구ID",
    election_district_name => "선거구 이름",
    election_district_short_name => "선거구 이름의 약칭",
    homo_id => "검색 인물 정보ID",
    cp_person_id => "CP 인물ID",
    cp_party_id => "CP 정당ID (candidate=actual 인 경우, cp_party_id_2, candidate=potential 인 경우, cp_party_id_1)",
    tw_tweets => "후보자 새 글",
    tw_rts => "RT",
    tw_mentions => "후보자를 언급한 글",
    tw_tweets_count => "글 수",
    tw_following_count => "following 수",
    tw_follower_count => "followers 수",
  };
  
  return (
    results => $candidate,
    help => $help,
    debug => {
      app1_mysql => (app1_mysql())[0],
      app2_mysql => (app2_mysql())[0],
    },
  );
}

sub election_candidate {
  my (@where, @where_param);
  foreach ( qw( homo_id cp_person_id cp_party_id_1 cp_party_id_2
                cp_election_district_id twitter_id ) ) {
    my @this_param = param($_);
    foreach my $value ( @this_param ) {
      push @where, "candidate.$_ = ?";
      push @where_param, $value;
    }
  }
  push @where, "1" if scalar @where < 1;
  my $sql_where = join(" OR ", @where);

  my @mysql_dsn = app2_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
  my $sql = q{
SELECT @rownum := @rownum + 1 AS rownum,
       d.*
FROM
( SELECT candidate.*, map.x AS wcongnamul_x, map.y AS wcongnamul_y
  FROM candidate, district_map_coordinates map
  WHERE candidate.cp_election_district_id = map.cp_election_district_id
        AND ( } . $sql_where . q{ )
) d,
( SELECT @rownum := 0 ) r
  };
  my $help = {
    nownum  => "순위",
    homo_id => "통합검색 인물ID",
    cp_person_id => "CP 인물ID",
    candidate_name => "후보자 이름",
    election_symbol => "기호",
    cp_party_id_1 => "CP 정당ID",
    cp_party_id_2 => "CP 정당ID",
    party_name => "정당이름",
    party_short_name => "정당이름 약칭",
    twitter_id => "트위터ID",
    #latitude  => "WGS-84 위도",
    #longitude => "WGS-84 경도",
  };

  return (
    results => $dbh->selectall_arrayref($sql, { Slice => {} }, @where_param),
    help => $help,
    debug => { mysql => $mysql_dsn[0], },
  );
}

sub tw_realtime_list {
  my @tweets;
  for (my $i=0;$i<10;$i++) {
    my %tweet = (
                  "date" => "2012-02-29 13:00:".(int(rand(49)) + 10),
                  "tweet" => "로렘 입섬 돌로어 시트 아메트, 콘섹테투어 아데피시시 엘리트, 세드 도 에이우스모드 템",
                  "twitter_id" => "xxxxx",
                  "permalink" => "twitter.com/xxxxx/28480802",
                );

    push(@tweets, \%tweet);
  }

  my $help = {
    "API:name" => "실시간 후보자 트윗",
    "API:desc" => "해당 후보자의 실시간 트윗 목록을 보여줌",
  };

  return (
    results => \@tweets,
    help => $help,
    debug => {
      app1_mysql => (app1_mysql())[0],
      app2_mysql => (app2_mysql())[0],
    },
  );
}

sub tw_rt_list {
  my @rts;
  for (my $i=0;$i<10;$i++) {
    my %rt = (
                  "date" => "2012-02-29 13:00:".(int(rand(49)) + 10),
                  "tweet" => "로렘 입섬 돌로어 시트 아메트, 콘섹테투어 아데피시시 엘리트, 세드 도 에이우스모드 템",
                  "twitter_id" => "xxxxx",
                  "permalink" => "twitter.com/xxxxx/28480802",
                );

    push(@rts, \%rt);
  }

  my $help = {
    "API:name" => "최다 RT 트윗",
    "API:desc" => "많이 RT된 후보자 트윗 최근, 24시간 이내 후보자 트윗 중 가장 많이 RT된 트윗 10건",
  };

  return (
    results => \@rts,
    help => $help,
    debug => {
      app1_mysql => (app1_mysql())[0],
      app2_mysql => (app2_mysql())[0],
    },
  );
}

sub realtime_ddm_dynamic_status {
  my $dbh = realtime_dbh();
  my ($max_id) = $dbh->selectrow_array( q{select max(id) from realtime_article});
  my ($min_id) = $dbh->selectrow_array( q{select min(id) from realtime_article});

  return ( status => {
    min_id  => $min_id,
    min_url => "$full_url/realtime_ddm_dynamic_list?from=$min_id",
    max_id  => $max_id,
    max_url => "$full_url/realtime_ddm_dynamic_list?from=$max_id",
  });
}

sub realtime_ddm_dynamic_list {
  my $from     = param('from');
  my $count    = param('count') || 100;

  my $dbh = realtime_dbh();
  ($from) = $dbh->selectrow_array(
              q{select max(id) from realtime_article}
            ) unless defined $from;

  my $sql = q(select * from realtime_article where id between ? and ?);
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} }, $from, $from+$count-1);

  my $max_id = $from;
  foreach my $row ( @{$list} ) {
    $max_id = $row->{id} if $max_id < $row->{id};
  }
  my $next = $max_id + 1;
  return (
    next_urls      => [ next_urls($q->url(-path_info=>1,-absolute=>1) . "?from=$next&count=$count") ],
    format_version => "json_breeze_ds_0.1",
    results           => $list,
  );
}

