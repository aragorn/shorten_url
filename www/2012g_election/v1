#!/usr/bin/perl -w
use strict;
use warnings;
use utf8;
use FindBin;
FindBin::again();
use CGI::Carp qw(warningsToBrowser fatalsToBrowser);
use CGI qw(:standard escape escapeHTML -utf8 -oldstyle_urls);
use JSON;
use Encode;
use Benchmark;
use Time::HiRes qw(gettimeofday tv_interval);

my ($BM1, $T01) = (new Benchmark, [gettimeofday]);

CGI->compile();

# This line should be commented out if output data is encoded properly.
#binmode STDOUT, ":encoding(UTF-8)";

our $q       = new CGI; $q->charset('utf-8'); # for proper escapeHTML
our $json    = new JSON; $json->allow_nonref->allow_blessed->utf8(1)->pretty(1);

# You should not call CGI::path_info() which does not support
# debugging mode from cmdline input.
my (undef, $query) = split(/\//o, $q->path_info() || "/index", 2);
my $from     = param('from')  || 0;
my $count    = param('count') || 100;
my $callback = param('callback');
my $content_type = "application/json";
   $content_type = "application/javascript" if $callback; # JSONP
my $full_url = $q->url(-full=>1);

print $q->header(-charset=>'utf-8', -type=>$content_type);
print jsonp_header($callback);

my %dispatch = (
  index                       => \&handler_index,
  district_list               => \&district_list,
  district                    => \&district,
  sns_map                     => \&sns_map,
  sns_map_detail              => \&sns_map_detail,
  realtime_ddm_dynamic_status => \&realtime_ddm_dynamic_status,
  realtime_ddm_dynamic_list   => \&realtime_ddm_dynamic_list,
  candidate                   => \&election_candidate,
);

my $output = {};
if ( defined $dispatch{$query} ) {
  my %result = &{$dispatch{$query}};
  map { $output->{$_} = $result{$_}; } keys %result;
  # Automating the utf8 encoding process.
  foreach my $row ( @{$output->{results}} ) {
    while ((my $key, my $value) = each(%$row)){
      eval {
        if ( defined $row->{$key} and not ref $row->{$key} ) {
          utf8::is_utf8($row->{$key})
            or $row->{$key}
                 = Encode::decode("utf8", $row->{$key});
        };
      };
      warn "Results $row->{$key} has invalid character in field $key" if $@;
    }
  }

  # Sorting "help" hashes by key.
  #sort %{$output->{help}} keys;
} else {
  $output->{hello} = "world!";
}

my ($BM2, $T02) = (new Benchmark, [gettimeofday]);
$output->{debug_info} = debug_info($BM1, $BM2, $T01, $T02);

print $json->encode($output);
print jsonp_footer($callback);

1;

sub jsonp_header {
  my ($callback) = @_;
  return <<END if $callback;
if (typeof $callback === "function") $callback(
END
  return "";
}

sub jsonp_footer {
  my ($callback) = @_;
  return <<END if $callback;
);
END
  return "";
}

sub debug_info {
  my ($t1, $t2, $t01, $t02) = @_;
  my $elapsed   = tv_interval($t01, $t02);
  my $benchmark = timestr(timediff($t2, $t1));
  my $mod_perl  = $ENV{MOD_PERL} || "";
  return { 
    elapsed   => "$elapsed secs",
    benchmark => "$benchmark",
    mod_perl  => "$mod_perl",
    json      => JSON->backend,
    encoding_test => "한글이 제대로 보이는지 점검합니다.",
  };
}

sub next_urls {
  my ($uri) = @_;
  return map { "$_$uri" } qw(
        http://search-twitter-app1:3080
        http://search-twitter-app2:3080
        http://search-twitter-app3:3080
    );
}

sub handler_index {
  return ( index => { map { $_ => "$full_url/$_" } sort keys %dispatch } );
}

sub mysql_dbh {
  use DBI;
  my $dbh = DBI->connect(@_);
  return $dbh;
}

###############################################################################
sub app1_mysql {
  my @slaves = (
    q(10.10.208.21),
    q(10.10.208.31),
    q(10.10.208.77),
  );
  my $host = $slaves[ int(rand(3)) ];
  my $schema  = "twapp1";
  my $db_user = "twapp1";
  my $db_pass = "app!@#";
  unless ( $q->server_port eq "80"
       and defined $ENV{GATEWAY_INTERFACE} ) {
     $schema  = "twapp1t";
     $db_user = "twapp1t";
     $db_pass = "app123";
  }
  return (qq(dbi:mysql:database=$schema;host=$host), $db_user, $db_pass);
}

sub app2_mysql {
  my @slaves = (
    q(10.10.208.21),
    q(10.10.208.31),
    q(10.10.208.77),
  );
  my $host = $slaves[ int(rand(3)) ];
  my $schema  = "twapp2";
  my $db_user = "twapp1";
  my $db_pass = "app!@#";
  unless ( $q->server_port eq "80"
       and defined $ENV{GATEWAY_INTERFACE} ) {
     $schema  = "twapp2t";
     $db_user = "twapp1t";
     $db_pass = "app123";
  }
  return (qq(dbi:mysql:database=$schema;host=$host), $db_user, $db_pass);
}

sub realtime_dbh {
  use DBI;
  my $database = q(dbi:mysql:database=realtime;host=10.30.143.73);
  my $db_user = q(cdwuser);
  my $db_pass = q(cdwuserdb);

  my $dbh = DBI->connect($database, $db_user, $db_pass);
  return $dbh;
}
###############################################################################

sub district_list {
  my $limit     = param('limit') || 15;

  my @mysql_dsn = app2_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
#  my $sql = q{
#SELECT @rownum := @rownum + 1 AS rownum,
#       sido_cd, sido_name, sido_short_name,
#       cp_election_district_id, election_district_short_name,
#       "37.4997677193116"  AS latitude,
#       "127.0294189453125" AS longitude,
#       cp_person_count,
#       tw_mentioned_count,
#       (tw_mentioned_count / 8000 * 100) AS tw_mentioned_share
#FROM
#( SELECT sido_cd, sido_name, sido_short_name,
#         cp_election_district_id, election_district_short_name,
#         COUNT(cp_person_id) AS cp_person_count,
#         ( FLOOR(RAND()*10) +
#           FLOOR(RAND()*1.2)*FLOOR(RAND()*10) +
#           FLOOR(RAND()*1.05)*FLOOR(RAND()*100) +
#           FLOOR(RAND()*1.05)*FLOOR(RAND()*1000) ) AS tw_mentioned_count
#  FROM candidate
#  GROUP BY cp_election_district_id
#  ORDER BY tw_mentioned_count DESC
#) d,
#( SELECT @rownum := 0 ) r
#LIMIT ?
#  };

  my $sql = q{
SELECT sido_cd, sido_name, sido_short_name,
       cp_election_district_id, election_district_short_name,
       group_concat(candidate_name) as candidate_name
FROM candidate
GROUP BY cp_election_district_id
  };
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} });

  $dbh = mysql_dbh(app1_mysql());
  $sql = q{
SELECT word, sum(mention_count) as cnt FROM wave_rank_mention_count 
where pub_date_begin > date_sub(now(), interval 1 day) group by word
  };
  my $counts_ref = $dbh->selectall_arrayref($sql, { Slice => {} });
  my %counts = ();
  foreach my $row ( @{$counts_ref} ) {
    my $word = Encode::decode("utf8", $row->{word});
    $counts{$word} = $row->{cnt};
  }

  foreach my $row ( @{$list} ) {
    #$row->{count} = $counts{'강기갑'};
    $row->{count} = $counts{강기갑};
  }

  # Sorting

  my $help = {
    "API:name" => "격전지 왼쪽 리스트",
    "API:desc" => "이 시각 SNS 격전지에서 사용, 기본 15개",
    nownum  => "순위",
    sido_cd => "특별/광역/도 코드",
    sido_name => "특별/광역/도 이름",
    sido_short_name => "특별/광역/도 이름의 약칭",
    cp_election_district_id => "CP_선거구ID",
    election_district_name => "선거구 이름",
    election_district_short_name => "선거구 이름의 약칭",
    tw_mentioned_count => "트위터에서 이름이 언급된 횟수",
    tw_mentioned_share => "트위터에서 이름이 언급된 점유율(%)",
    cp_person_count => "선거구의 후보자 수",
    latitude  => "WGS-84 위도",
    longitude => "WGS-84 경도",
  };

  return (
    results => $list,
    help => $help,
    debug => { mysql => $mysql_dsn[0], },
  );
}

sub district {
  my $district_id = param('district_id');

  my @mysql_dsn = app2_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
  my $sql = q{
SELECT @rownum := @rownum + 1 AS rownum,
       homo_id, cp_person_id, candidate_name, election_symbol,
       cp_party_id_1, cp_party_id_2, party_name, party_short_name,
       twitter_id,
       tw_mentioned_count,
       (tw_mentioned_count / 200 * 100) AS tw_mentioned_share
FROM
( SELECT homo_id, cp_person_id, candidate_name, election_symbol,
         cp_party_id_1, cp_party_id_2, party_name, party_short_name,
         twitter_id,
         ( FLOOR(RAND()*5) +
           FLOOR(RAND()*1.5)*FLOOR(RAND()*50) +
           FLOOR(RAND()*1.9)*FLOOR(RAND()*100) ) AS tw_mentioned_count
  FROM candidate
  WHERE cp_election_district_id = ?
  ORDER BY tw_mentioned_count DESC
) d,
( SELECT @rownum := 0 ) r
  };
  
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} }, $district_id);
  foreach my $row ( @{$list} ) {
    my @histories = ("20.2","24.1","20.1","11.4","17.8","16");
    $row->{shared_history} = \@histories;
  }

  my $help = {
    "API:name" => "격전지 상세",
    "API:desc" => "",
    nownum  => "순위",
    homo_id => "통합검색 인물ID",
    cp_person_id => "CP 인물ID",
    candidate_name => "후보자 이름",
    election_symbol => "기호",
    cp_party_id_1 => "CP 정당ID",
    cp_party_id_2 => "CP 정당ID",
    party_name => "정당이름",
    party_short_name => "정당이름 약칭",
    twitter_id => "트위터ID",
    tw_mentioned_count => "트위터에서 이름이 언급된 횟수",
    tw_mentioned_share => "트위터에서 이름이 언급된 점유율(%)",
    shared_history => "최근 6일간 점유율 히스토리(%)",
    
    #latitude  => "WGS-84 위도",
    #longitude => "WGS-84 경도",
  };

  return (
    results => $list,
    help => $help,
    debug => { mysql => $mysql_dsn[0], },
  );
}

sub sns_map_detail {
  my $homo_id = param('homo_id');

  my @mysql_dsn = app2_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
  my $sql = q{
select * from candidate where homo_id = ?
  };
 
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} }, $homo_id);

  foreach my $row ( @{$list} ) {
    $row->{total} = 2421551;
    $row->{homo_id} = int(rand(10000));
    $row->{cp_person_id} = int(rand(10000));
    $row->{cp_party_id} = 1;
  }

  my $help = {
    "API:name" => "SNS 맵",
    "API:desc" => "후보자 SNS 점유율 맵을 그리기 위한 용도",
    word => "언급된 후보자명",
    cnt => "언급된 횟수(하루단위)",
    total => "전체 언급 횟수",
    date => "조회 날짜",
    home_id => "",
    cp_person_id => "",
    cp_party_id => "정당 코드",
  };
  
  return (
    results => $list,
    help => $help,
    debug => { mysql => $mysql_dsn[0], },
  );
}

sub election_candidate {
  my (@where, @where_param);
  foreach ( qw( homo_id cp_person_id cp_party_id_1 cp_party_id_2
                cp_election_district_id twitter_id ) ) {
    my @this_param = param($_);
    foreach my $value ( @this_param ) {
      push @where, "$_ = ?";
      push @where_param, $value;
    }
  }
  push @where, "1" if scalar @where < 1;
  my $sql_where = join(" OR ", @where);

  my @mysql_dsn = election_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
  my $sql = q{
SELECT @rownum := @rownum + 1 AS rownum,
       d.*
FROM
( SELECT *
  FROM candidate
  WHERE } . $sql_where . q{
) d,
( SELECT @rownum := 0 ) r
  };
  my $help = {
    nownum  => "순위",
    homo_id => "통합검색 인물ID",
    cp_person_id => "CP 인물ID",
    candidate_name => "후보자 이름",
    election_symbol => "기호",
    cp_party_id_1 => "CP 정당ID",
    cp_party_id_2 => "CP 정당ID",
    party_name => "정당이름",
    party_short_name => "정당이름 약칭",
    twitter_id => "트위터ID",
    #latitude  => "WGS-84 위도",
    #longitude => "WGS-84 경도",
  };

  return (
    results => $dbh->selectall_arrayref($sql, { Slice => {} }, @where_param),
    help => $help,
    debug => { mysql => $mysql_dsn[0], },
  );
}

sub realtime_ddm_dynamic_status {
  my $dbh = realtime_dbh();
  my ($max_id) = $dbh->selectrow_array( q{select max(id) from realtime_article});
  my ($min_id) = $dbh->selectrow_array( q{select min(id) from realtime_article});

  return ( status => {
    min_id  => $min_id,
    min_url => "$full_url/realtime_ddm_dynamic_list?from=$min_id",
    max_id  => $max_id,
    max_url => "$full_url/realtime_ddm_dynamic_list?from=$max_id",
  });
}

sub realtime_ddm_dynamic_list {
  my $from     = param('from');
  my $count    = param('count') || 100;

  my $dbh = realtime_dbh();
  ($from) = $dbh->selectrow_array(
              q{select max(id) from realtime_article}
            ) unless defined $from;

  my $sql = q(select * from realtime_article where id between ? and ?);
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} }, $from, $from+$count-1);

  my $max_id = $from;
  foreach my $row ( @{$list} ) {
    $max_id = $row->{id} if $max_id < $row->{id};
  }
  my $next = $max_id + 1;
  return (
    next_urls      => [ next_urls($q->url(-path_info=>1,-absolute=>1) . "?from=$next&count=$count") ],
    format_version => "json_breeze_ds_0.1",
    results           => $list,
  );
}

sub sns_map {
  use Time::localtime;
  my $t = localtime;
  
  my $date = param('date') || sprintf( "%04d-%02d-%02d", $t->year + 1900, $t->mon + 1, $t->mday);
  my $cp_party_id = param('cp_party_id') || 1;

  my @mysql_dsn = app1_mysql();
  my $dbh = mysql_dbh(@mysql_dsn);
  my $sql = q{
select word, sum(mention_count) as cnt, left(pub_date_begin, 10) as date
from wave_rank_mention_count w where left(pub_date_begin, 10) = ?
group by left(pub_date_begin, 10), word order by cnt desc limit 100
  };
 
  my $list = $dbh->selectall_arrayref($sql, { Slice => {} }, $date);

  foreach my $row ( @{$list} ) {
    $row->{total} = 2421551;
    $row->{homo_id} = int(rand(10000));
    $row->{cp_person_id} = int(rand(10000));
    $row->{cp_party_id} = 1;
  }

  my $help = {
    "API:name" => "SNS 맵",
    "API:desc" => "후보자 SNS 점유율 맵을 그리기 위한 용도",
    word => "언급된 후보자명",
    cnt => "언급된 횟수(하루단위)",
    total => "전체 언급 횟수",
    date => "조회 날짜",
    home_id => "",
    cp_person_id => "",
    cp_party_id => "정당 코드",
  };

  return (
    results => $list,
    help => $help,
    debug => { mysql => $mysql_dsn[0], },
  );
}
